---
title: "MBD_QBS181_Final"
author: "Monica Dimambro"
date: "2023-10-12"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Libraries
```{r}
library(dplyr) # for data manipulation
library(deSolve) # for SIR plot
library(rootSolve) # for SIR plot

library(rvest) # for webscraping population info

# ==== for mapping (used chatGPT to find packages to avoid large world shapefile) ====
library(ggplot2)
library(sf)
library(rnaturalearth)
```



# OLD CLASS MATERIAL
1. Build a model with three compartments – susceptible (S), infected/infectious (I) and recovered (R). Use the following initial conditions:

0.0001% of the population is infected
Everyone else is susceptible

Old: (The transmission rate is 1.4)
IS TRANSMISSION RATE SAME AS BETA?

Transmission rate from here: https://www.ncbi.nlm.nih.gov/pmc/articles/PMC3323341/
Median R0 in Canada = 0.58
Median R0 in Hong Kong = 1.10
Median R0 in Singapore = 1.17
B = 0.25 in Hong Kong (source: Chowell 2004)
Gamma = 28.4 (source: Chowell 2004)

Recovery rate from here: ???
The recovery rate is 0.1

Solution from here: http://rstudio-pubs-static.s3.amazonaws.com/6852_c59c5a2e8ea3456abbeb017185de603e.html
```{r}
## Create an SIR function
sir <- function(time, state, parameters) {

  with(as.list(c(state, parameters)), {

    dS <- -beta * S * I
    dI <-  beta * S * I - gamma * I
    dR <-                 gamma * I

    return(list(c(dS, dI, dR)))
  })
}

### Set parameters
## Proportion in each compartment: Susceptible 0.999999, Infected 0.000001, Recovered 0
init       <- c(S = 1-1e-6, I = 1e-6, R = 0.0)
## beta: infection parameter; gamma: recovery parameter
parameters <- c(beta = 0.25, gamma = (1/28.4))
## Time frame
times      <- seq(0, 70, by = 1)

## Solve using ode (General Solver for Ordinary Differential Equations)
out <- ode(y = init, times = times, func = sir, parms = parameters)
## change to data frame
out <- as.data.frame(out)
## Delete time variable
out$time <- NULL
## Show data
head(out, 10)
```

Plot these curves
```{r}
plot(out$S~times, type='l', col = "red", xlab = "Time (d)", ylab = "Proportion of Pop in Compartment", main = "Susceptible Population")

plot(out$I~times, type='l', col = "dark green", xlab = "Time (d)", ylab = "Proportion of Pop in Compartment", main = "Infectious Population", ylim = c(0,0.8))

plot(out$R~times, type='l', col = "blue", xlab = "Time (d)", ylab = "Proportion of Pop in Compartment", main = "Recovered Population")
```
2. What is R0 for this epidemic?
```{r}
beta = 0.25
gamma = 1/28.4
(r0 <- beta/gamma) # 7.1
```

3. Plot the time series of membership in each compartment. At the peak of the epidemic, what proportion of the population is infected? What is the proportion of the population infected during the epidemic (final size)?
```{r}
max(out$I)*100 # 56.1% of pop infected at peak

# at end, what proportion of population had been infected:
tail(out) # 20.4% of pop
```

Overlay plots (from link)
```{r}
## Plot
matplot(x = times, y = out, type = "l",
        xlab = "Time", ylab = "Susceptible and Recovered", main = "SIR Model",
        lwd = 1, lty = 1, bty = "l", col = 2:4)

## Add legend
legend(40, 0.7, c("Susceptible", "Infected", "Recovered"), pch = 1, col = 2:4, bty = "n")
```


6. Find transmission and recovery rates that correspond to an R0<1. What happens?
```{r}
parameters4 <- c(beta = 0.05, gamma = 0.1) # this works
times      <- seq(0, 400, by = 1)

## Solve using ode (General Solver for Ordinary Differential Equations)
out4 <- ode(y = init, times = times, func = sir, parms = parameters4)
## change to data frame
out4<- as.data.frame(out4)
## Delete time variable
out4$time <- NULL
## Show data
tail(out4, 10)

## Plot
matplot(x = times, y = out4, type = "l",
        xlab = "Time", ylab = "Susceptible and Recovered", main = "SIR Model",
        lwd = 1, lty = 1, bty = "l", col = 2:4, )

## Add legend
legend(40, 0.7, c("Susceptible", "Infected", "Recovered"), pch = 1, col = 2:4, bty = "n")
```

# Challenge: Model an intervention 

7. Reset your model so that the transmission rate is back to 1.4 and the recovery rate is 0.1. Then, introduce a vaccine that protects 80% of the population before the start of the epidemic (hint: set your initial conditions so that 80% of the population is already in the recovered compartment). What happens to the epidemic curve? What if 95% of the population is vaccinated?
```{r}
# 80% vaccination
parameters5 <- c(beta = 1.4, gamma = 0.1) # this works
times      <- seq(0, 200, by = 1)
init       <- c(S = (1-1e-6)*0.2, I = (1e-6), R = 0.0 + (1-1e-6)*0.8)

## Solve using ode (General Solver for Ordinary Differential Equations)
out5 <- ode(y = init, times = times, func = sir, parms = parameters5)
## change to data frame
out5<- as.data.frame(out5)
## Delete time variable
out5$time <- NULL
## Show data
tail(out5, 10)

## Plot
matplot(x = times, y = out5, type = "l",
        xlab = "Time", ylab = "Susceptible and Recovered", main = "SIR Model",
        lwd = 1, lty = 1, bty = "l", col = 2:4, )

## Add legend
legend(40, 0.7, c("Susceptible", "Infected", "Recovered"), pch = 1, col = 2:4, bty = "n")

```

8. The final size of an epidemic is an important property can be found a little more easily using the function runsteady() in the rootSolve package. This function will attempt to find equilibria of systems of differential equations through numerical integration. It is a wrapper around ode() and they take (almost) the same arguments – check the 
documentation.  

9.  Reset your model so that the transmission rate is back to 1.4, the recovery rate is 0.1, and no one has been vaccinated. Use runsteady() to find the final size of the epidemic.  
```{r}
# ======== reset model ==========
parameters6 <- c(beta = 0.25, gamma = (1/28.4)) 
times      <- seq(0, 400, by = 1)
init       <- c(S = 1-1e-6, I = (1e-6), R = 0.0)

## Solve using ode (General Solver for Ordinary Differential Equations)
out6 <- ode(y = init, times = times, func = sir, parms = parameters6)
## change to data frame
out6<- as.data.frame(out6)
## Delete time variable
out6$time <- NULL

# =========== runSteady() ==========
# finding steady state (prop of pop) in each compartment
equil <- runsteady(y = init, func = sir, parms = parameters6, times = c(0, 400)) # I will start to go negative at times = c(0, 10000)
(equil$y)
```


10.  Compute the epidemic final size for a range of Total_Pops of R0 from 0 to 10. Make a plot of the relationship between R0 and final size.  
```{r}
(equil$y) # R = 9.999990e-01

final_size <- NULL
rnot <- seq(0,10,0.1)
init <- c(S = 8.318748e-04, I = 4.844463e-06, R = 9.991633e-01)

for (r in rnot){
  parameters <- c(beta = r*0.1, gamma = 0.1)
  equil <- runsteady(y = init, func = sir, parms = parameters, times = c(0, Inf))
  final_size <- c(final_size, equil$y[3])
}

fs_rnot <- data.frame(final_size, rnot)

plot(fs_rnot$rnot, fs_rnot$final_size, type = "l", col = "blue", xlab = "R0", ylab = "Final Prop. of Pop. Recovered (%)")
```



## ===== start of final project ========

Read in Data
```{r}
sars <- read.csv("~/Desktop/Dartmouth/6. Fall 2023 Term/QBS 181 Data Wrangling/5. Final Project/sars_2003_complete_dataset_clean.csv")
head(sars)
demos <- read.csv("~/Desktop/Dartmouth/6. Fall 2023 Term/QBS 181 Data Wrangling/5. Final Project/summary_data_clean.csv")
head(demos)
```

Sort sars by country name
```{r}
sars <- sars[order(sars$Country),]
head(sars)
```

Count number of entries per country
```{r}
country_n <- sars %>% group_by(Country) %>% count(Country) 

head(country_n)

country_n <- country_n[order(country_n$n),]
barplot(country_n$n ~ country_n$Country)
```

Start by plotting 3 plots for each country
```{r}
# countries <- unique(sars$Country)
# sars$Date <- as.Date(sars$Date)
# 
# for (country in countries){
#   df <- sars %>% filter(Country == country)
#   plot(Cumulative.number.of.case.s. ~ Date, type='l', data=df, main=paste("Cumulative Number of SARS Cases in ", country))
#   plot(Number.of.deaths ~ Date, type='l', data=df, main=paste("Number of Deaths from SARS in ", country))
#   plot(Number.recovered ~ Date, type='l', data=df, main=paste("Number of Recovered from SARS in ", country))
# }
```


Scraping pop table (used chatGPT for starter)
```{r}
# Define the URL of the website
url <- "https://theodora.com/wfb2003/rankings/population_2003_0.html"

# Read the HTML content of the page
webpage <- read_html(url)

# Extract the table from the webpage using CSS selectors
pop <- webpage %>%
  html_table(fill = TRUE) %>%
  .[[2]]  # Second table on the page is the one we want

# Print the scraped table
print(pop)

# drop second col
pop <- pop[,-c(2)]

# set first row equal to colnames
colnames(pop) <- c('Rank','Country','Total_Pop')

# drop first row
pop <- pop[-c(1),]

# look
head(pop)

# convert pop to int
pop$Total_Pop <- gsub(",", "", pop$Total_Pop)
pop$Total_Pop <- as.integer(pop$Total_Pop)
head(pop)
```

Merge rank and population onto sars df and demos df
```{r}
# rewrite some country names in sars so match country names in pop on merge
sars$Country <- ifelse(sars$Country == 'Hong Kong SAR, China', 'Hong Kong', 
                              ifelse(sars$Country == 'Taiwan, China', 'Taiwan', 
                                     ifelse(sars$Country == 'Macao SAR, China', 'Macau',
                                            ifelse(sars$Country == 'Republic of Ireland', 'Ireland',
                                                   ifelse(sars$Country == 'Republic of Korea', 'Korea, South', 
                                                          ifelse(sars$Country == 'Russian Federation', 'Russia', 
                                                                 ifelse(sars$Country == 'Viet Nam', 'Vietnam', sars$Country)))))))

# rewrite some country names in demos so match country names in sars for later
colnames(demos)[1] <- "Country"
demos$Country <- ifelse(demos$Country == 'Hong Kong SAR, China', 'Hong Kong', 
                              ifelse(demos$Country == 'Taiwan, China', 'Taiwan', 
                                     ifelse(demos$Country == 'Macao SAR, China', 'Macau',
                                            ifelse(demos$Country == 'Republic of Ireland', 'Ireland',
                                                   ifelse(demos$Country == 'Republic of Korea', 'Korea, South', 
                                                          ifelse(demos$Country == 'Russian Federation', 'Russia', 
                                                                 ifelse(demos$Country == 'Viet Nam', 'Vietnam', demos$Country)))))))

# merge
sars <- merge(sars, pop, left_on = "Country", right_on = "Country", all.x=T)

# convert date in sars to date type
sars$Date <- as.Date(sars$Date)

# convert sars rank to int
sars$Rank <- as.integer(sars$Rank)

head(sars)
```

Plot
```{r}
# # first create smaller df with max's
sars_subset <- sars %>% group_by(Country) %>% summarise_all(last)
print(sars_subset)
# 
# # plot
# ggplot(sars_subset, aes(x = Rank, y = Cumulative.number.of.case.s., size = Number.of.deaths)) +
#   geom_point(aes(color = Number.of.deaths), alpha = 0.7) +
#   scale_size_continuous(range = c(5, 30)) +  # Adjust the range for bubble sizes
#   labs(title = "Bubble Plot of COVID-19 Data",
#        x = "Population Ranking",
#        y = "Cumulative Number of Cases",
#        size = "Number of Deaths") +
#   theme_minimal()  # You can customize the theme as needed
```

Drop countries with less than 10 cumulative cases
```{r}
sars_subset2 <- sars_subset %>% filter(Cumulative.number.of.case.s. >= 10)
head(sars_subset2)

```

Subset sars df and demos df to only have the countries in list of countries with cum. num. deaths greater than 10
```{r}
# ===== sars df =====
sars_countries <- c('Canada', 'China', 'Hong Kong', 'Philippines', 'Singapore', 'Taiwan')
subset_sars <- sars[sars$Country %in% sars_countries, c(1:5)]
head(subset_sars)

# merge in pop and rank
subset_sars <- merge(subset_sars, pop, by = "Country")
subset_sars$Rank <- as.integer(subset_sars$Rank)
head(subset_sars)

# ==== demos df ====
subset_demos <- demos[demos$Country %in% sars_countries,]
head(subset_demos)
```

Some cleaning (dates to dates, etc.)
```{r}
# ====== subset_demos ======
# convert dates
subset_demos$Date.onset.first.probable.case <- as.Date(subset_demos$Date.onset.first.probable.case)
subset_demos$Date.onset.last.probable.case <- as.Date(subset_demos$Date.onset.last.probable.case)
head(subset_demos)

# split into age of youngest case and age of oldest case (used chatGPT for help here)
# Split the age range into Youngest and Oldest columns
age_split <- strsplit(subset_demos$Age.range, "-")

# Create new columns for Youngest and Oldest
subset_demos$youngest_case <- sapply(age_split, function(x) as.integer(x[1]))
subset_demos$oldest_case <- sapply(age_split, function(x) as.integer(x[2]))

# bring in population then clean
subset_demos <- merge(subset_demos, pop[,c(2:3)], by = "Country")
colnames(subset_demos)[17] <- "Total_Population"
head(subset_demos)
```

```{r}
# try lm with subset of demos
model <- lm(Cumulative.total.cases ~ Case.fatalities.ratio.... + Date.onset.first.probable.case + Median.age + Percentage.of.Imported.cases + Percentage.of.HCW.affected + youngest_case + oldest_case + Total_Population, data = subset_demos)

# Summarize the model
summary(model)

# try with full demos
# rename countries to match pop df
demos_pop <- merge(demos, pop, on = "Country")
head(demos_pop)

mod2 <- lm(Cumulative.total.cases ~ Case.fatalities.ratio.... + Median.age + Percentage.of.Imported.cases + Percentage.of.HCW.affected + Total_Pop, data = demos_pop)

# Summarize the model
summary(mod2)

# only Percentage.of.Imported.cases and Percentage.of.HCW.affected is significant (estimate = -3.461, p < 0.0001 and estimate = -3.273 and p = 0.006)
```

# plot world

Clean names to match worldDF "name"
```{r}
sars_subset$Country <- ifelse(sars_subset$Country == 'Korea, South', 'Korea',
                              ifelse(sars_subset$Country == 'Macau', 'Macao',sars_subset$Country))
```

Merge pop data onto "world" data
```{r}
# order world$name and pop$Country
world <- world[order(world$name),]
pop <- pop[order(pop$Country),]
check <- as.data.frame(cbind(pop$Country, world$name))
writexl::write_xlsx(check, "~/Desktop/Dartmouth/6. Fall 2023 Term/QBS 181 Data Wrangling/5. Final Project/check_country_names.xlsx")

world <- ne_countries(scale = "medium", returnclass = "sf")
world <- merge(world, pop, by.x = "name", by.y = "Country", all.x=T)
```

Plot in ggplot
```{r}
ggplot() +
  geom_sf(data = world, aes(fill = Total_population), color = "white") +
  scale_fill_viridis_c(option = "C", na.Total_Pop = "grey") +  # You can change the color palette
  labs(title = "World Map by Population") +
  theme_void()
```

Merge cumulative cases data onto "world" data
```{r}
world <- ne_countries(scale = "medium", returnclass = "sf")
world <- merge(world, sars_subset[,c(1,3)], by.x = "name", by.y = "Country", all.x=T)
```

Plot in ggplot
```{r}
ggplot() +
  geom_sf(data = world, aes(fill = Cumulative.number.of.case.s.), color = "white") +
  scale_fill_viridis_c(option = "C", na.Total_Pop = "grey") +  # You can change the color palette
  labs(title = "World Map by Number of SARS Cases") +
  theme_void()
```

Merge cumulative cases data onto "world" data
```{r}
world <- ne_countries(scale = "medium", returnclass = "sf")
world <- merge(world, sars_subset[,c(1,4)], by.x = "name", by.y = "Country", all.x=T)
```

Plot in ggplot
```{r}
ggplot() +
  geom_sf(data = world, aes(fill = Number.of.deaths), color = "white") +
  scale_fill_viridis_c(option = "C", na.Total_Pop = "grey") +  # You can change the color palette
  labs(title = "World Map by Number of SARS Deaths") +
  theme_void()
```
